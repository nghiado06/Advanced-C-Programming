# Tìm hiểu về Pointer (Con trỏ)
- **Tìm hiểu tổng quan về con trỏ**
  - Khái niệm
  - Cú pháp khai báo, truy xuất
  - Kích thước
  - Ứng dụng và Ý nghĩa
- **Các loại con trỏ**
  - Cú pháp khai báo
  - Ý nghĩa và cách sử dụng của từng loại con trỏ đó. 
# 1. Tìm hiểu tổng quan về con trỏ (pointer)
## 1.1 Khái niệm
- Trong ngôn ngữ lập trình C, con trỏ (pointer) là một biến chứa địa chỉ bộ nhớ của một đối tượng khác (biến, mảng, hàm). Việc sử dụng con trỏ giúp chúng ta thực hiện các thao tác trên bộ nhớ một cách linh hoạt hơn.
## 1.2 Cú pháp khai báo
- Khai báo

```cpp
  data_type *pointer_name;
```
- Gán giá trị: do giá trị của một con trỏ là địa chỉ của một biến khác nên ta sẽ kết hợp toán tử & để lấy địa chỉ của 1 biến. Và bản thân con trỏ cũng là 1 biến đang sử dụng 1 địa chỉ khác nữa.
```cpp
  pointer_name = &variable;
```

Ví dụ:

```cpp
int x = 10; //Địa chỉ: 0x01
int *ptr; // Địa chỉ con trỏ: 0x02
ptr = &x; // Giá trị con trỏ: 0x01
```

## 1.3 Truy xuất giá trị
- Ta sử dụng toán tử * để lấy giá trị của địa chỉ mà con trỏ đang trỏ tới.
```cpp
int x = 10; //Địa chỉ: 0x01
int *ptr; //Địa chỉ con trỏ: 0x02
ptr = &x; //Giá trị con trỏ: 0x01
*ptr = 15; //Truy cập vào giá trị của địa chỉ là con trỏ trỏ tới *ptr = *(&x) = x = 15
printf("%d", x); //Khi này x = 15
```
output
```
15
```

******Lưu ý:****** Khi sử dụng con trỏ, kiểu dữ liệu con trỏ và kiểu dữ liệu địa chỉ mà con trỏ trỏ tới phải giống nhau.
```cpp
int *ptr;
float x = 10;
ptr = &x; //Báo lỗi
```

## 1.4 Kích thước con trỏ
- Kích thước của con trỏ phụ thuộc vào **kiến trúc máy tính và trình biên dịch** hoặc **kiến trúc vi xử lý**.

```cpp
#include <stdio.h>

int main() {
    int *ptr;
    printf("Size of pointer: %d bytes\n", sizeof(ptr));
    return 0;
}
```
output
```
Size of pointer: 8 bytes //Kết quả này là do hệ điều hành của tôi đang ở 64-bit. Con số này có thể thay đổi.
```

## 1.5 Ứng dụng và Ý nghĩa
- Con trỏ giúp **can thiệp trực tiếp** vào vùng nhớ của biến, thay vì làm việc với một bản sao cục bộ trong stack. Điều này giúp thay đổi giá trị thực của biến trong bộ nhớ, tránh việc trình biên dịch tạo ra một biến tạm thời khi truyền tham số theo giá trị.
<br>
**Khi không dùng con trỏ:**
```cpp
#include <stdio.h>

void changeValue(int x) {
    x = 10;
}

int main() {
    int num = 5;
    changeValue(num);
    printf("Giá trị của num: %d\n", num);  // Vẫn là 5
    return 0;
}
```
output
```
Giá trị của num: 5
```
--> Khi này giá trị của num không thay đổi vì:
  - Hàm changeValue đã tạo 1 biến tạm thời cục bộ sao chép giá trị của x là 5 sau đổi thay đổi nó thành 10 và biến tạm thời này sẽ được trả lại bộ nhớ sau khi thoát hàm.

```cpp
void changeValue(int x) {
    x = 10;  // Thay đổi x, nhưng chỉ thay đổi bản sao trong stack
}

int main() {
    int num = 5; //Địa chỉ: 0x01
    changeValue(num); //Biến tạm thời có địa chỉ: 0x02. Giá trị biến tạm thời: 10
    printf("Giá trị của num: %d\n", num);  // Giá trị biến num vẫn là 5
    return 0;
}
```
**Khi dùng con trỏ**
```cpp
#include <stdio.h>

void changeValue(int *x) {
    *x = 10;  // Thay đổi giá trị tại địa chỉ của x
}

int main() {
    int num = 5;
    changeValue(&num);  // Truyền địa chỉ của num
    printf("Giá trị của num: %d\n", num);  // Bây giờ là 10
    return 0;
}

```
--> Khi này chúng ta đã can thiệp trực tiếp vào địa chỉ của biến num và thay đổi giá trị của nó.
