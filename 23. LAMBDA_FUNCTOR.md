# NỘI DUNG TÌM HIỂU
- Hôm nay chúng ta sẽ cùng tìm hiểu về các nội dung trong C++ sau:
- Lambda:
  - Khái niệm
  - Đặc điểm
  - Các cách sử dụng Lambda
- Functor:
  - Khái niệm
  - Đặc điểm
- Giờ cùng bắt đầu tìm hiểu thôi!

# 1. LAMBDA EXPRESSION
## 1.1 Khái niệm
- Lambda là một hàm ẩn danh (anonymous function), tức là một hàm không cần tên và có thể khai báo ngay tại nơi cần dùng.
- Cú pháp:

```cpp
[capture](parameters) --> return type {
  //function body
}
```

- Trong đó:
  - parameter_lists: danh sách tham số (giống hàm toàn cục).
  - return_type: kiểu trả về (có thể tự động suy diễn, thường không cần ghi rõ).
  - {...}: thân hàm.
  - capture: cho biết cách sử dụng các biến xung quanh lambda.

## 1.2 Các cách sử dụng
### 1. Cách gọi và khai báo

- Lambda sẽ có 2 cách gọi:
  - Gọi trực tiếp: gọi trực tiếp sẽ chỉ được gọi cục bộ, không gọi được toàn cục.
  - Trong đó ta phải kết hợp với sử dụng toán tử () để có thể gọi nội dung bên trong lambda nhưng gọi một hàm bình thường.
    - Lấy ví dụ:

    ```cpp
    #include <iostream>
    using namespace std;

    []()
    {
      cout << Hello World << endl;
    }; //Báo lỗi chưa định nghĩa
    
    int main()
    {
      []()
      {
        cout << "Hello World" << endl;
      }();
    
      return 0;
    }
    
    ```

    output

    ```
    Hello World
    ```
    
  - Kết hợp với biến: có thể gọi toàn cục hoặc cục bộ đều được.
  - Bên cạnh đó, kết hợp với biến cũng có 2 cách sử dụng:
    - nếu như gọi hàm một cách trực tiếp bằng toán tử () thì khi này biến sẽ bằng giá trị trả về của lambda.
    - nếu như gán lambda bằng biến thì biến đó sẽ như một hàm bình thường.
  - Lấy ví dụ:

  ```cpp
    #include <iostream>
    using namespace std;

    auto funct = []()
    {
      cout << Hello World << endl;
    }; // Không còn báo lỗi nữa

    funct(); //Gọi biến khi nãy như một hàm bình thường
    
    int main()
    {
      auto funct2 = []()
      {
        return 1 + 2;
      }(); // Đã gọi trực tiếp như này bằng toán tử () thì biến funct2 khi này sẽ bằng giá trị trả về của lambda.

      cout << funct2 << endl; 
    
      return 0;
    }
  ```

  output

  ```
  Hello World
  3
  ```
 
### 2. Cách sử dụng
- Bây giờ chúng ta sẽ tìm hiểu cách sử dụng lambda, thao tác với các từ khóa capture, para ở trên.

#### Lambda đơn giản (Không capture - para - không return-type)
- Nó sẽ là lambda mà chúng ta đã sử dụng ở trên.

```cpp
auto funct = []()
{
  cout << "Hello World";
};

funct();
```

#### Lambda có tham số

- Chúng ta sẽ truyền tham số như một hàm bình thường.

```cpp
auto square = [](int x) {
    return x * x;
};

cout << square(5);  // 25
```

#### Lambda có capture
- Lambda sử dụng capture sẽ có 4 loại nữa:
  - [<name_variable>]: truyền giá trị của biến cụ thể sẽ sử dụng.
  - [=]: truyền giá trị tất cả các biến bên ngoài.
  - [&<name_variable>]	: truyền tham chiếu của biến cụ thể
  - [&]: truyền tham chiếu của tất cả biến bên ngoài
  - Phối hợp các dạng trên.

_**Capture by Value**_
- Capture by value sẽ chỉ **đọc** được giá trị tham số truyền vào, **không tác động** được giá trị.
- Và capture by value này sẽ có thể đọc được giá trị của tất cả biến xung quanh.

```cpp
int a = 5;
int b = 4;
auto lam = [=]() {
  cout << a << " ";
  int c = b;
  cout << c << endl;
}; 
lam();  // 5 4
```

**_Capture by Reference_**
- Capture by reference sẽ tác động trực tiếp đến biến gốc.
- Và capture by reference này sẽ có thể nhận được giá trị của tất cả biến xung quanh.

```cpp
int a = 5;
int b = 4;
auto swap = [&]() {
  int c = b;
  b = a;
  a = c;
}; 
swap();
cout << a << endl; // 4
cout << b << endl; // 5
```

_**Capture cụ thể**_
- Nó sẽ chỉ đọc hoặc ghi giá trị lên biến cụ thể được truyền vào.
- Có phối hợp giữa by value và by reference.

```cpp
int a = 3, b = 4;
auto lam = [a, &b]() {
  cout << a << endl; // 3
  b = 5;
};
cout << b; // 5
```

#### Capture có return-type cụ thể
- Như các ví dụ trên return-type sẽ được trình biên dịch tự suy ra. Vậy thì return-type này có ý nghĩa gì nữa?
- Thực chất là nó sẽ rất quan trọng trong những tình huống cụ thể.
- Lấy ví dụ:

```cpp
auto f = [](bool flag) {
    if (flag) return 3;      // int
    else return 3.5;         // double
}; // Báo lỗi vì conflict kiểu trả về
```

- Trong trường hợp trên thì trình biên dịch sẽ không thể tự suy được nữa, vậy nên ta cần chỉ định rõ kiểu trả về là gì.

```cpp
auto f = [](bool flag) -> double  {
    if (flag) return 3;      // int
    else return 3.5;         // double
}; // Báo lỗi vì conflict kiểu trả về
```

#### Lambda Mutable
- Nó sẽ tương tự với capture by value, nhưng sẽ khác ở chỗ là lần này nó không chỉ đọc mà nó sẽ có thể tạo một biến copy
 với biến capture.
- Nó sẽ tương tự như truyền tham số cho hàm bình thường vậy.
- Lấy ví dụ:

```cpp
int count = 0;
auto lam = [count]() mutable {
    count++;
    std::cout << count << "\n";
};

lam();  // 1
lam();  // 2

cout << count; // 0
```

#### Lambda Truyền Vào STL
- Nó sẽ như một comparator hay các callable object cho các stl.
- Vậy ưu điểm của nó so với hàm bình thường là gì?.
- Nó sẽ có ưu điểm:
  - Ngắn gọn, viết tại chỗ không cần khai báo trước hay đặt tên. Đặc biệt là với các hàm không cần tái sử dụng.
  - Có giữ được trạng thái state bằng capture. Hay nói cách khác, nó có thể sử dụng biến bên ngoài mà không cần truyền vào như tham số. Điều mà các hàm bình thường không làm được.
- Lấy ví dụ:

```cpp
int threshold = 10;
std::count_if(v.begin(), v.end(), [threshold](int x) {
    return x > threshold;
}); //Biến threshold được sử dụng từ bên ngoài
```

# 2. FUNCTOR
## 2.1 Khái Niệm
- Trong C++, Functor (Function Object - Đối tượng hàm) là một đối tượng (object) có thể hoạt động như một hàm.
- Nói cách khác, functor là một đối tượng của class (struct) có định nghĩa toán tử operator () để có thể gọi ra như một hàm thông thường.
- Nhớ lại một chút về cách sử dụng một operator overloading:

```cpp
return_type operator symbol (parameter_list) {
};
```

- Thì functor chính là một operator được định nghĩa với symbol là () để cho đối tượng có thể sử dụng được và hoạt động như một hàm.
- Cú pháp:

```cpp
return_type operator()(parameter_list) const{};
```













