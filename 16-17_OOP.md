# OOP là gì?
- OOP là viết tắt của Object-Oriented Programming.
- OOP là một phương pháp lập trình tổ chức chương trình thành các **đối tượng (objects)** – mỗi đối tượng là một sự kết hợp giữa **dữ liệu (thuộc tính)** và **hành vi (phương thức/hàm).**
- OOP có 4 tính chất cơ bản:
  - **Tính đóng gói (Encapsulation)**
  - **Tính kế thừa (Inheritance)**
  - **Tính đa hình (Polymorphism)**
  - **Tính trừu tượng (Abstraction)**

**Vậy thì bây giờ chúng ta cùng tìm hiểu 4 tính chất trên**

# 1. TÍNH ĐÓNG GÓI (ENCAPSULATION)
- **Tính đóng gói (Encapsulation)** là ẩn đi các property “mật” khỏi người dùng. Và để làm được điều này, ta sẽ khai báo các property ở quyền truy cập private/protected (tức là không thể truy cập trực tiếp tới các property này thông qua object bên ngoài) ở nội dung trước. 
- Trong trường hợp ta muốn đọc hoặc ghi các property này, thì ta sẽ truy cập gián tiếp thông qua các method ở quyền truy cập public.
- Hay nói cách khác là chúng ta sẽ đóng gói các quy trình quan trọng private lại bằng 1 phương thức public. Khi đó ta nói phương thức được public này là một **trừu tượng** mà chúng ta sẽ tìm hiều sau bên dưới.
- Lấy ví dụ:

```cpp
#include <iostream>

using namespace std;

class SinhVien
{
  private:
    int id;
    string name;

  public:
    void getName(string newName);
    void getID(int newID);
    void display();
};

void SinhVien::getName(string newName)
{
  name = newName;
}

void SinhVien::getID(int newID)
{
  id = newID;
}

void SinhVien::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout <<  "MSSV: " << id << endl; 
}

int main()
{
  SinhVien sv1;
  sv1.name = "Do Duc Nghia"; //báo lỗi truy cập
  sv1.getName("Do Duc Nghia");
  sv1.getID(2412257);
  sv1.display();

  return 0;
}

```

output

```
Ho va Ten: Do Duc Nghia
MSSV: 2412257
```

- Khi này người dùng nếu muốn chỉnh sửa giá trị Tên và ID cho đối tượng thì phải thông qua phương thực getName và getID.

# 2. TÍNH TRỪU TƯỢNG
- Tính trừu tượng về bản chất cũng sẽ là sự kết hợp giữa việc giấu đi các property/method quan trọng và public các phương thức.
- Nó có sự tương quan chặt chẽ với tính đóng gói. 2 tính chất này bổ trợ cho nhau.
- Lấy ví dụ:

```cpp
class CoffeeMachine
{
private:
    void grindBeans() {...}
    void boilWater() {...}
    void brewCoffee() {...}

public:
    void makeCoffee() {
        grindBeans();
        boilWater();
        brewCoffee();
    }
};
```

- Khi này tôi nói, người dùng chỉ cần gọi makeCoffee (tức là 1 **trừu tượng**) để thực hiện một chuỗi các quy trình grindBeans, boilWater, brewCoffee đã được **đóng gói** kỹ càng.

# 3. TÍNH KẾ THỪA
## 3.1 Đặt vấn đề
- Đặt vấn đề, nếu như ta có các property hay method được lặp đi lặp lại quá nhiều trong các class, thì chúng ta có thể gộp chúng lại để dễ quản lý hơn không?
- Điều này là hoàn toàn có thể như đối với việc ta gộp các câu lệnh có mối quan hệ được lặp đi lặp lại quá nhiều vào 1 hàm để có thể gọi và dễ quản lý.
- Vấn đề: thuộc tính ten, id được lặp lại quá nhiều lần.

```cpp
class SinhVien
{
    public:
        string ten;
        int id;
        string chuyenNganh;
};

class HocSinh
{
    public:
        string ten;
        int id;
        string lop;
};

class GiaoVien
{
    public:
        string ten;
        int id;
        string chuyenMon;
};

```

## 3.2 Tính kế thừa

- Tính kế thừa ( Inheritance) là khả năng sử dụng lại các property và method của một class trong một class khác và có thể mở rộng thêm tính năng. Ta chia chúng làm 2 loại là class cha và class con. 
- Để kế thừa từ class khác, ta dùng ký tự ":".
- Có 3 kiểu kế thừa là public, private và protected. Những property và method được kế thừa từ class cha sẽ nằm ở quyền truy cập của class con tương ứng với kiểu kế thừa.

## Kế thừa public
- Các member public của class cha vẫn sẽ là public trong class con.
- Các member protected của class cha vẫn sẽ là protected trong class con.
- Các member private của class cha không thể truy cập trực tiếp từ class con nhưng có thể được truy cập gián tiếp qua các phương thức public hoặc protected của class cha.
- Lấy ví dụ:

```cpp
#include <iostream>
using namespace std;

class DoiTuong
{
private:
    void Private()
    {
        cout << "Day la khu vuc private" << endl;
    }

protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
};

class SinhVien : public DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
};

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

int main()
{
    SinhVien sv1;
    sv1.id = 2412257;   // Báo lỗi vì protected trong class cha vẫn là protected trong class con
    sv1.Private();      // Báo lỗi truy cập
    sv1.setID(2412257); // Không báo lỗi
    sv1.setName("Do Duc Nghia");
    sv1.setMajor("Co Dien Tu");
// Khi này có thể thấy đối tượng mặc dù được tạo bởi class SinhVien nhưng vẫn có các thuộc tính id, name và phương thức setName, setID
    return 0;
}
```

## Kế thừa Protected
- Tương tự với kế thừa public, các member public, protected của class cha sẽ là protected trong class con.

```cpp
#include <iostream>
using namespace std;

class DoiTuong
{
private:
    void Private()
    {
        cout << "Day la khu vuc private" << endl;
    }

protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
};

class SinhVien : protected DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
};

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

int main()
{
    SinhVien sv1;
    sv1.id = 2412257;   // Báo lỗi vì protected trong class cha vẫn là protected trong class con
    sv1.Private();      // Báo lỗi truy cập
    sv1.setID(2412257); // Báo lỗi truy cập
    sv1.setName("Do Duc Nghia"); // Báo lỗi truy cập
    sv1.setMajor("Co Dien Tu");
// Khi này các phương thức public của class cha không gọi được từ class con nữa.
    return 0;
}
```
## Kế thừa Private
- Các member public, protected của class cha sẽ trở thành private trong class con.

## Đa kế thừa
- Đa kế thừa là khi một class con kế thừa các thuộc tính hay phương thức của nhiều class cha cùng 1 lúc.
- Và khi sử dụng đa kế thừa không đúng cách sẽ xảy ra 1 vấn đề? Hãy cùng tìm hiểu vấn đề này.
- Trước tiên bắt đầu với đa kế thừa:

```cpp
class A
{
public:
  void a()
  {
    cout << "Day la ham A!" << endl;
  }
};

class B:public A
{
public:
  void b()
  {
    cout << "Day la ham B!" << endl;
  }
};

class C:public A
{
public:
  void c()
  {
    cout << "Day la ham C!" << endl;
  }
};

class D:public B, public C
{
public:
  void d()
  {
    cout << "Day la ham D!" << endl;
  }
};

int main()
{
  D d;
  d.a(); // Báo lỗi
}
```
- Khi này class D đã kế thừa các thuộc tính và phương thức của class B và C, nhưng class B và C đều kế thừa cùng 1 class đó là A.
- Và khi ta gọi hàm a() trong đối tượng d, khi đó sẽ xảy ra 1 vấn đề hay lỗi đó chính là **Diamond Problem**.
- Diamond Problem là khi ta cố gọi hàm a() trong đối tượng d, nhưng vì d đã kế thừa class B, C và cả 2 class này đều kế thừa được hàm a(), nên trình biên dịch sẽ không hiểu là hàm a() được gọi trong class B hay C, khi đó sẽ xảy ra xung đột, hay mơ hồ (ambiguity).
- Khi này, ta có thể xử lý bằng 2 cách:
  - Chỉ định trực tiếp hàm được gọi thông qua class nào.
  - Xử dụng **Kế thừa ảo**, chúng ta sẽ tìm hiểu sau.

#### Cách chỉ định trực tiếp

```cpp
class A
{
public:
  void a()
  {
    cout << "Day la ham A!" << endl;
  }
};

class B:public A
{
public:
  void b()
  {
    cout << "Day la ham B!" << endl;
  }
};

class C:public A
{
public:
  void c()
  {
    cout << "Day la ham C!" << endl;
  }
};

class D:public B, public C
{
public:
  void d()
  {
    cout << "Day la ham D!" << endl;
  }
};

int main()
{
  D d;
  d.B::a(); //Khi này không báo lỗi nữa
}
```

# 4. TÍNH ĐA HÌNH (POLYMORPHISM)
- Tính đa hình ( Polymorphism) có nghĩa là "nhiều dạng" và nó xảy ra khi chúng ta có nhiều class có liên quan với nhau thông qua tính kế thừa.
- Tính đa hình có thể được chia thành hai loại chính:
  - Đa hình tại thời điểm biên dịch (Compile-time Polymorphism).
  - Đa hình tại thời điểm chạy (Run-time Polymorphism).
- Đa hình hay nói một cách dễ hiểu là **một hành động nhưng nhiều cách thực hiện**.
- Trước tiên hãy cùng tìm hiểu một số từ khóa và mục đính sử dụng đa hình:
  - Down-casting/Up-casting
  - Virtual/Overload/Override/Đa hình runtime/Pure Virtual Function

## 4.1 Down-casting/Up-casting
- Down-casting là khi chúng ta ép kiểu cho class cha về class con.
- Up-casting là khi chúng ta ép kiểu cho class con lên class cha.

```cpp
class DoiTuong
{
protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
    void display();
};

class SinhVien : public DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
    void display();
};

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void DoiTuong::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
}

void SinhVien::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
  cout << "Chuyen Nganh: " << chuyenNganh << endl;
}

int main()
{
  //Khởi tạo sinh viên
  SinhVien sv1;
  sv1.setName("Do Duc Nghia");
  sv1.setID(2412257);
  sv1.setMajor("Co Dien Tu");

  //Khởi tạo đối tượng
  DoiTuong *dt1;
  dt1 = &sv1;
  dt1->display();
}
```

output

```
Ho va Ten: Do Duc Nghia
MSSV: 2412257
```

- Khi này, ta thấy mặc dù con trỏ đã trỏ đến địa chỉ của đối tượng sv1, nhưng vì đã được khởi tạo bởi class DoiTuong nên khi in ra cũng sẽ chỉ in các thuộc tính của class DoiTuong thôi.
- Vậy nếu muốn in ra các thuộc tính của class SinhVien, khi này ta phải ép kiểu cho đối tượng dt1.

```cpp
class DoiTuong
{
protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
    void display();
};

class SinhVien : public DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
    void display();
};

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void DoiTuong::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
}

void SinhVien::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
  cout << "Chuyen Nganh: " << chuyenNganh << endl;
}

int main()
{
  //Khởi tạo sinh viên
  SinhVien sv1;
  sv1.setName("Do Duc Nghia");
  sv1.setID(2412257);
  sv1.setMajor("Co Dien Tu");

  //Khởi tạo đối tượng
  DoiTuong *dt1;
  dt1 = &sv1;
  ((SinhVien *)dt1)->display();
}
```

output

```
Ho va Ten: Do Duc Nghia
MSSV: 2412257
Chuyen Nganh: Co Dien Tu
```

## 4.2 Virtual Function/Overload/Override/ Virtual Inheritence
### Virtual Function

- Đối với trường hợp trên, nếu như mỗi lần ta muốn gọi phương thức của một class nào đó, thay vì phải ép kiểu về như vậy, ta có thể sử dụng **từ khóa virtual** hay là **hàm ảo**.
- Hàm ảo là một hàm thành viên được khai báo trong class cha với từ khóa virtual.
- Khi một hàm là virtual, nó có thể được ghi đè (override) trong class con để cung cấp cách triển khai riêng.
- Khi gọi một hàm ảo thông qua một con trỏ hoặc tham chiếu đến lớp con, hàm sẽ được quyết định dựa trên đối tượng thực tế mà con trỏ hoặc tham chiếu đang trỏ tới chứ không dựa vào kiểu của con trỏ.
- Lấy lại ví dụ trước:

```cpp
class DoiTuong
{
protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
    virtual void display();
};

class SinhVien : public DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
    void display();
};

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void DoiTuong::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
}

void SinhVien::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
  cout << "Chuyen Nganh: " << chuyenNganh << endl;
}

int main()
{
  //Khởi tạo sinh viên
  SinhVien sv1;
  sv1.setName("Do Duc Nghia");
  sv1.setID(2412257);
  sv1.setMajor("Co Dien Tu");

  //Khởi tạo đối tượng
  DoiTuong *dt1;
  dt1 = &sv1;
  dt1->display();
}
```

output

```
Ho va Ten: Do Duc Nghia
MSSV: 2412257
Chuyen Nganh: Co Dien Tu
```

### Override/Overload/Đa hình run-time

- Override là **ghi đè**, còn overload là **nạp chồng**. Sự khác biệt dễ nhất đó chính là:
- Việc overload một hàm nào đó, không nhất thiết phải gọi chính xác hàm cũ, hay nói cách khác là gọi một hàm cùng tên nhưng với tính chất khác (ví dụ như việc thêm tham số cho hàm).
- Việc override một hàm bắt buộc phải là sử dụng lại chính xác hàm đó và ghi đè những nội dung mới vào.
- Khi một hàm ảo được ghi đè, hành vi của nó sẽ phụ thuộc vào kiểu của đối tượng thực tế, chứ không phải kiểu của con trỏ hay tham chiếu.
- Tính đa hình run-time xảy ra khi quyết định gọi hàm nào (phiên bản của class cha hay class con) được đưa ra tại thời điểm chạy, không phải lúc biên dịch, giúp mở rộng chức năng. Điều này giúp chương trình linh hoạt hơn, cho phép việc mở rộng chức năng mà không cần sửa đổi mã nguồn hiện tại.
- Ta cùng phân biệt như sau:

```cpp
class DoiTuong
{
protected:
    int id;
    string name;

public:
    void setName(string newName);
    void setID(int newID);
    virtual void display();
    virtual void overload()
    {
      cout << "Ham nay se duoc overload" << endl;
    }
};

class SinhVien : public DoiTuong
{
private:
    string chuyenNganh;

public:
    void setMajor(string Major);
    void display() override; // Khi này hàm sẽ override với lên hàm cũ
    void overload(int x, int y) override; /*Khi này sẽ báo lỗi vì hàm này đã được thay đổi với các tham số đầu vào, trình biên dịch sẽ hiểu rằng đây là hàm khác so với hàm ảo ban đầu và không được phép ghi đè. và Khi ta muốn overload nó ta phải bỏ đi từ khóa virtual.*/
};

void DoiTuong::setID(int newID)
{
    id = newID;
}

void DoiTuong::setName(string newName)
{
    name = newName;
}

void DoiTuong::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
}

void SinhVien::overload(int x, int y)
{
  cout << "Day la ham overload trong class Sinh Vien" << endl;
}

void SinhVien::setMajor(string Major)
{
    chuyenNganh = Major;
}

void SinhVien::display()
{
  cout << "Ho va Ten: " << name << endl;
  cout << "MSSV: " << id << endl;
  cout << "Chuyen Nganh: " << chuyenNganh << endl;
}
```

### Virtual Inheritence
- Quay lại vấn đề trong nội dung trước, khi chúng ta cố gắng đa kế thừa, sẽ xảy ra lỗi đó chính là **diamond problem**.
- Khi này, ngoài cách chỉ định trực tiếp thì chúng ta có thể sử dụng từ khóa virtual cho class kế thừa, hay còn gọi là virtual inheritence.
- Virtual Inheritence (Kế thừa ảo) là kỹ thuật trong C++ dùng để giải quyết xung đột khi kế thừa nhiều lớp có chung tổ tiên.
- Lấy ví dụ:

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    A()
    {
        cout << "Constructor A" << endl;
    }

    void hienthiA()
    {
        cout << "Day la lop A" << endl;
    }
};

class B : virtual public A
{
public:
    B()
    {
        cout << "Constructor B" << endl;
    }

    void hienthiB()
    {
        cout << "Day la lop B" << endl;
    }
};

class C : virtual public A
{
public:
    C()
    {
        cout << "Constructor C" << endl;
    }

    void hienthiC()
    {
        cout << "Day la lop C" << endl;
    }
};

// Diamond Problem với hàm daKeThua, khắc phục bằng virtual ngay đầu hàm (kế thừa ảo)
class D : public B, public C
{
public:
    D()
    {
        cout << "Constructor D" << endl;
    }

    void hienthiD()
    {
        cout << "Day la lop D" << endl;
    }
};

int main()
{
    D d;
    d.hienthiB();
    d.B::hienthiA();
    d.hienthiA();

    return 0;
}
```

## 4.3 Pure Virtual Function
- Hàm thuần ảo là một hàm ảo không có phần định nghĩa trong class cha, được khai báo với cú pháp = 0 và khiến class cha trở thành class trừu tượng (abstract class), nghĩa là không thể tạo đối tượng từ class này.
- 3 đặc điểm cơ bản:
  - Không thể khởi tạo đối tượng từ class cha trừu tượng.
  - Không thể khởi tạo từ class con kế thừa class cha trừu tượng nếu không định nghĩa/ghi đè lại hàm thuần ảo.
  - Có thể khai báo bằng con trỏ.
- Ứng dụng:
  - Khi chúng ta muốn khởi tạo 1 mô hình chung nhưng không muốn ai khởi tạo đối tượng từ nó.
  - Muốn sử dụng kế thừa để quản lý các đối tương một cách hệ thống hơn.

```cpp
#include <iostream>

using namespace std;

class Parent
{
public:
    virtual void func() = 0;
};

class Child : public Parent
{
    void func() override
    {
        cout << "Day la ham ao da duoc dinh nghia lai!";
    }
};

class Kid : public Parent
{
};

int main()
{
    Child cld; // Không báo lỗi vì đã định nghĩa lại
    Parent prt; // Báo lỗi trừu tượng
    Kid kid; // Báo lỗi trừu tượng
    Parent *prt2;

    return 0;
}
```
