# NỘI DUNG TÌM HIỂU
****1. Tìm hiểu về 2 loại cấu trúc dữ liệu****
- Stack: Cấu trúc dữ liệu ngăn xếp
- Queue: Cấu trúc dữ liệu hàng đợi

**--> Tìm hiểu về khái niệm, đặc điểm, cách sử dụng của 2 kiểu cấu trúc dữ liệu trên.**

****2. Tìm hiểu về cách build thư viện, thiết lập cấu trúc code chuẩn AUTOSAR****
- Build thư viện .h theo các quy tắc chuẩn AUTOSAR
- Sử dụng Makefile để run các chương trình, thư viện được bố trí trong cấu trúc thư mục khác nhau.

# 1. CẤU TRÚC DỮ LIỆU LÀ GÌ?
- Cấu trúc dữ liệu là cách tổ chức, và lưu trữ dữ liệu để chúng có thể được truy cập và sử dụng một cách hiệu quả, đóng vai trò quan trọng trong việc giải quyết các bài toán và tối ưu hóa thuật toán, vì nó ảnh hưởng trực tiếp đến tốc độ thực thi và tính phức tạp của chương trình.
- Cấu trúc dữ liệu được phân làm 2 loại chính:
  - Cấu trúc dữ liệu tuyến tính **(Linear Data Structure)**: mảng (Array), ngăn xếp (Stack), hàng đợi (Queue), danh sách liên kết (Linked List).
  - Cấu trúc dữ liệu phi tuyến tính **(Non-linear Data Structure)**: đồ thị (Graphs), cây (Trees)

# 2. STACK
## 2.1 Khái niệm
- **Stack (ngăn xếp)** là một cấu trúc dữ liệu tuân theo nguyên tắc **"Last In, First Out" (LIFO)**, nghĩa là phần tử cuối cùng được thêm vào stack sẽ là phần tử đầu tiên được lấy ra.
- Các thao tác cơ bản trên stack:
  - **init:** khởi tạo stack
  - **push:** thêm phần tử vào đỉnh của stack
  - **pop:** xóa phần tử khỏi đỉnh của stack
  - **peek/top:** lấy giá trị phần tử ở đỉnh stack
  - **isFull/isEmpty:** kiểm tra stack đầy/rỗng
  - **stack_free:** Hàm giải phóng stack
 
## 2.2 Tìm hiểu các thao tác:
### 1. Khởi tạo khái niệm stack
- Stack sẽ bao gồm thông số cố định cơ bản:
  - Mảng chứa các phần tử
  - Chỉ số của phần tử ở đỉnh
  - Số lượng phần tử
- Tạo một cấu trúc stack:

```cpp
typedef struct
{
    int *item; // Mảng (cấp phát động) chứa các giá trị chèn vào
    int top;   // Chỉ số lấy giá trị ở đỉnh
    int size;  // Số lượng phần tử tối đa
} Stack;
```

### 2. Hàm init

- Hàm init khởi tạo stack với các tham số đầu vào bằng cách cấp phát cho mảng item và định kích thước stack. 

```cpp
void init(Stack *stack, int newSize)
{
    stack->item = (int *)malloc(newSize * sizeof(int)); // Cấp phát động cho con trỏ item
    stack->top = -1; // Đặt chỉ số top bằng -1, tức là stack rỗng chưa có phần tử.
    stack->size = newSize; // Định kích thước cho stack với tham số truyền vào
}
```

### 3. Hàm kiểm tra rỗng/đầy
- Kiểm tra đầy bằng cách so sánh chỉ số top với kích thước stack. Vì là chỉ số phần tử đầu tiên bằng 0 nên stack đầy khi chỉ số top bằng size - 1.
- Kiểm tra rỗng bằng cách kiểm tra chỉ số top, nếu top = -1 tức là stack rỗng.

```cpp
bool isEmpty(Stack stack)
{
    return (stack.top == -1 ? true : false);
}

bool isFull(Stack stack)
{
    return (stack.top == (stack.size - 1) ? true : false);
}
```

### 4. Hàm push

```cpp

void push(Stack *stack, int data)
{
  // Kiểm tra xem stack đầy hay rỗng, nếu đầy không thể push thêm phần tử nữa.
    if (isFull(*stack))
    {
        printf("Khong the them. Stack da day\n");
    }
    else
    {
        stack->item[++(stack->top)] = data; // Tăng chỉ số top lên và gán giá trị đầu vào cho phần tử ở chỉ số top mới này. Ở đây lưu ý một chút về độ ưu tiên toán tử.
        printf("Data: %d - Element: %d Push Successfully!\n", data, stack->top);
    }
}
```

**Độ ưu tiên toán tử:** ở hàm trên, độ ưu tiên toán tử thể hiện ở cú pháp ++(stack->top). Vậy điểm khác biệt giữa cú pháp này với cú pháp
(stack->top)++ ở chỗ nào.

<br>

Lấy ví dụ:

```cpp
int arr[3] = {0,1,2};
int i = 0;
int j = 0;
printf("%d\n", arr[++i]);
printf("%d\n", arr[j++]);
```

output

```
1
0
```
Điểm khác biệt nằm ở chỗ, nếu sử dụng i++ thì mảng sẽ đọc giá trị i = 0 trước nên sẽ trả về phần tử đầu tiên.
<br>
Còn đối với ++j thì khi này giá trị j sẽ tăng lên 1 trước, sau đó mảng mới đọc giá trị j mới này. Nên mảng sẽ trả về phần tử thứ 2.

<br>

Tương tự cho hàm trên, 2 đoạn code này sẽ tương đương nhau:

```cpp
stack->item[++(stack->top)] = data;
```

```cpp
stack->top++;
stack->item[stack->top] = data;
```

## 5. Hàm pop
- Hàm pop hoạt động bằng gán giá trị đỉnh bằng 0 và hạ chỉ số top xuống.

```cpp
int pop(Stack *stack)
{
    if (isEmpty(*stack))
    {
        printf("Stack Empty!\n");
        return STACK_EMPTY; // #define STACK_EMPTY -1
    }
    else
    {
        int val = stack->item[stack->top]; // Lưu giá trị phần tử đỉnh trước khi bị xóa
        stack->item[stack->top--] = 0; // Gán giá trị phần tử đỉnh bằng 0 và dời chỉ số top xuống
        return val; // Trả giá trị phần tử cuối
    }
}
```

## 6. Hàm top
- Hàm top giúp trả về giá trị phần tử đỉnh

```cpp
int top(Stack stack)
{
    if (isEmpty(stack))
    {
        printf("Stack is Empty!\n");
        return STACK_EMPTY;
    }
    else
    {
        return stack.item[stack.top]; //Trả về giá trị phần tử top
    }
}
```

## 7. Hàm stack_free
- Stack về bản chất cũng là sử dụng bộ nhớ cấp phát động với vùng nhớ trên bộ nhớ Heap. Nên khi kết thúc chúng ta vẫn cần phải giải phóng nó.
- stack_free là hàm có vai trò giải phóng vùng nhớ này.

```cpp
void stack_free(Stack *stack)
{
    if (stack->item != NULL)
    {
        free(stack->item); // Giải phóng bộ nhớ
        stack->item = NULL; // Gán cho con trỏ này bằng NULL để tránh việc con trỏ trỏ đến các địa chỉ rác
    }
}
```

## 8. Chương trình hoàn chỉnh tham khảo

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "stack.h"


typedef struct
{
    int *item; // Mảng (cấp phát động) chứa các giá trị chèn vào
    int top;   // Chỉ số lấy giá trị ở đỉnh
    int size;  // Số lượng phần tử tối đa
} Stack;

#define STACK_EMPTY -1

void init(Stack *stack, int newSize)
{
    stack->item = (int *)malloc(newSize * sizeof(int));
    stack->top = -1;
    stack->size = newSize;
}

bool isEmpty(Stack stack)
{
    return (stack.top == -1 ? true : false);
}

bool isFull(Stack stack)
{
    return (stack.top == (stack.size - 1) ? true : false);
}

void push(Stack *stack, int data)
{
    if (isFull(*stack))
    {
        printf("Khong the them. Stack da day\n");
    }
    else
    {
        stack->item[++(stack->top)] = data;
        printf("Data: %d - Element: %d Push Successfully!\n", data, stack->top);
    }
}

int pop(Stack *stack)
{
    if (isEmpty(*stack))
    {
        printf("Stack Empty!\n");
        return STACK_EMPTY;
    }
    else
    {
        int val = stack->item[stack->top];
        stack->item[stack->top--] = 0;
        return val;
    }
}

int top(Stack stack)
{
    if (isEmpty(stack))
    {
        printf("Stack is Empty!\n");
        return STACK_EMPTY;
    }
    else
    {
        return stack.item[stack.top];
    }
}

void stack_free(Stack *stack)
{
    if (stack->item != NULL)
    {
        free(stack->item);
        stack->item = NULL;
    }
}

int main()
{
    Stack stack1;

    init(&stack1, 5);

    printf("Push Process...\n");
    for (int i = 1; i <= stack1.size; ++i)
    {
        push(&stack1, i * 5);
    }

    printf("\n");

    printf("Print Elements...\n");

    for (int i = 0; i < stack1.size; ++i)
    {
        printf("Element: %d - Address: %d - Value: %d\n", i + 1, &(stack1.item[i]), stack1.item[i]);
    }

    printf("\n");

    printf("Pop Process...\n");

    for (int i = 0; i < stack1.size; i++)
    {
        printf("Element: %d - Address: %d - Value: %d\n", i + 1, &(stack1.item[stack1.top]), stack1.item[stack1.top]);
        pop(&stack1);
    }

    return 0;
}
```

output

```
Push Process...
Data: 5 - Element: 0 Push Successfully!
Data: 10 - Element: 1 Push Successfully!
Data: 15 - Element: 2 Push Successfully!
Data: 20 - Element: 3 Push Successfully!
Data: 25 - Element: 4 Push Successfully!

Print Elements...
Element: 1 - Address: 7603376 - Value: 5
Element: 2 - Address: 7603380 - Value: 10
Element: 3 - Address: 7603384 - Value: 15
Element: 4 - Address: 7603388 - Value: 20
Element: 5 - Address: 7603392 - Value: 25

Pop Process...
Element: 1 - Address: 7603392 - Value: 25
Element: 2 - Address: 7603388 - Value: 20
Element: 3 - Address: 7603384 - Value: 15
Element: 4 - Address: 7603380 - Value: 10
Element: 5 - Address: 7603376 - Value: 5
```

# 3. QUEUE
- Queue là một cấu trúc dữ liệu tuân theo nguyên tắc **"First In, First Out" (FIFO)**, nghĩa là phần tử đầu tiên được thêm vào hàng đợi sẽ là phần tử đầu tiên được lấy ra.
- Chúng ta sẽ tìm hiểu 2 loại Queue:
  - Linear Queue (Hàng đợi tuyến tính)
  - Circular Queue (Hàng đợi vòng)
- Các thao tác cơ bản với queue:
-   **init:** khởi tạo hàng đợi
-   **enqueue:** thêm phần tử vào cuối hàng đợi
-   **dequeue:** xóa phần tử ở đầu hàng đợi
-   **front:** để lấy giá trị của phần tử đầu hàng đợi
-   **rear:** để lấy giá trị của phần tử đứng cuối hàng đợi
-   **queue_isFull/queue_isEmpty:** kiểm tra hàng đợi đầy hay rỗng
-   **queue_free:** tương tự với stack, hàm này dùng để giải phóng queue


## 3.1 LINEAR QUEUE
### 1. Định nghĩa
- Trong Linear Queue, nếu ‘rear’ đã đạt tới max, thì queue sẽ được coi là đầy và không thể thêm phần tử mới, ngay cả khi phía trước còn khoảng trống do các phần tử đã bị xóa.
- Chỉ có thể thêm phần tử mới khi đã dequeue toàn bộ các phần tử hiện có (tức là queue rỗng hoàn toàn và front được reset về vị trí ban đầu).
### 2. Các hàm thao tác
#### 2.1 Cấu trúc queue
- Cấu trúc queue bao gồm 4 thông số cơ bản:
-   Mảng để chứa các phần tử
-   Kích thước hàng đợi
-   Chỉ số đầu hàng
-   Chỉ số cuối hàng

```cpp
typedef struct
{
    int *item;
    int size;
    int front;
    int rear;
} Queue;
```
#### 2.2 Hàm init
- Hàm init giúp khởi tạo các thông số ban đầu cho queue. Bao gồm:
-   Kích thước queue
-   Chỉ số đầu hàng và chỉ số cuối hàng đều bằng -1.
-   Cấp phát mảng cho queue

```cpp
void queue_init(Queue *queue, int newSize)
{
    queue->item = (int *)calloc(newSize, sizeof(int));
    queue->size = newSize;
    queue->front = -1;
    queue->rear = -1;
}
```

#### 2.2 Hàm kiểm tra đầy/rỗng
- Điều kiện để hàng đầy: rear = size - 1. Tức là chỉ số cuối hàng bằng với kích thước - 1 (Do phần tử đầu tiên có chỉ số bằng 0)
- Điều kiện để hàng rỗng:
-   rear = -1 (Chỉ số cuối hàng không thay đổi)
-   front > rear: chỉ số đầu hàng lớn hơn chỉ số cuối hàng. Lý do là vì mỗi lần dequeue thì chỉ số front sẽ tăng lên. Và khi xóa đi phần tử cuối hàng rồi thì chỉ số front sẽ lớn hơn chỉ số rear.

```cpp
bool queue_isFull(Queue queue)
{
    return ((queue.rear == queue.size - 1) ? true : false);
}

bool queue_isEmpty(Queue queue)
{
    return ((queue.rear == -1) || (queue.front > queue.rear) ? true : false);
```


