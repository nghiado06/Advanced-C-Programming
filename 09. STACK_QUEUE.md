# TÌM HIỂU VỀ 2 LOẠI CẤU TRÚC DỮ LIỆU
- Stack: Cấu trúc dữ liệu ngăn xếp
- Queue: Cấu trúc dữ liệu hàng đợi

--> Tìm hiểu về khái niệm, đặc điểm, cách sử dụng của 2 kiểu cấu trúc dữ liệu trên.

# 1. CẤU TRÚC DỮ LIỆU LÀ GÌ?
- Cấu trúc dữ liệu là cách tổ chức, và lưu trữ dữ liệu để chúng có thể được truy cập và sử dụng một cách hiệu quả, đóng vai trò quan trọng trong việc giải quyết các bài toán và tối ưu hóa thuật toán, vì nó ảnh hưởng trực tiếp đến tốc độ thực thi và tính phức tạp của chương trình.
- Cấu trúc dữ liệu được phân làm 2 loại chính:
  - Cấu trúc dữ liệu tuyến tính (Linear Data Structure): mảng (Array), ngăn xếp (Stack), hàng đợi (Queue), danh sách liên kết (Linked List).
  - Cấu trúc dữ liệu phi tuyến tính (Non-linear Data Structure): đồ thị (Graphs), cây (Trees)

# 2. STACK
## 2.1 Khái niệm
- Stack (ngăn xếp) là một cấu trúc dữ liệu tuân theo nguyên tắc "Last In, First Out" (LIFO), nghĩa là phần tử cuối cùng được thêm vào stack sẽ là phần tử đầu tiên được lấy ra.
- Các thao tác cơ bản trên stack:
  - init: khởi tạo stack
  - push: thêm phần tử vào đỉnh của stack
  - pop: xóa phần tử khỏi đỉnh của stack
  - peek/top: lấy giá trị phần tử ở đỉnh stack
  - isFull/isEmpty: kiểm tra stack đầy/rỗng
 
## 2.2 Tìm hiểu các thao tác:
### Khởi tạo khái niệm stack
- Stack sẽ bao gồm thông số cố định cơ bản:
  - Mảng chứa các phần tử
  - Chỉ số của phần tử ở đỉnh
  - Số lượng phần tử
- Tạo một cấu trúc stack:

```cpp
typedef struct
{
    int *item; // Mảng (cấp phát động) chứa các giá trị chèn vào
    int top;   // Chỉ số lấy giá trị ở đỉnh
    int size;  // Số lượng phần tử tối đa
} Stack;
```

### Hàm init

- Hàm init khởi tạo stack với các tham số đầu vào bằng cách cấp phát cho mảng item và định kích thước stack. 

```cpp
void init(Stack *stack, int newSize)
{
    stack->item = (int *)malloc(newSize * sizeof(int)); // Cấp phát động cho con trỏ item
    stack->top = -1; // Đặt chỉ số top bằng -1, tức là stack rỗng chưa có phần tử.
    stack->size = newSize; // Định kích thước cho stack với tham số truyền vào
}
```

### Hàm kiểm tra rỗng/đầy
- Kiểm tra đầy bằng cách so sánh chỉ số top với kích thước stack. Vì là chỉ số phần tử đầu tiên bằng 0 nên stack đầy khi chỉ số top bằng size - 1.
- Kiểm tra rỗng bằng cách kiểm tra chỉ số top, nếu top = -1 tức là stack rỗng.

```cpp
bool isEmpty(Stack stack)
{
    return (stack.top == -1 ? true : false);
}

bool isFull(Stack stack)
{
    return (stack.top == (stack.size - 1) ? true : false);
}
```

### Hàm push

```cpp

void push(Stack *stack, int data)
{
  // Kiểm tra xem stack đầy hay rỗng, nếu đầy không thể push thêm phần tử nữa.
    if (isFull(*stack))
    {
        printf("Khong the them. Stack da day\n");
    }
    else
    {
        stack->item[++(stack->top)] = data; // Tăng chỉ số top lên và gán giá trị đầu vào cho phần tử ở chỉ số top mới này. Ở đây lưu ý một chút về độ ưu tiên toán tử.
        printf("Data: %d - Element: %d Push Successfully!\n", data, stack->top);
    }
}
```

**Độ ưu tiên toán tử:** ở hàm trên, độ ưu tiên toán tử thể hiện ở cú pháp ++(stack->top). Vậy điểm khác biệt giữa cú pháp này với cú pháp
(stack->top)++ ở chỗ nào.

<br>

Lấy ví dụ:

```cpp
int arr[3] = {0,1,2};
int i = 0;
int j = 0;
printf("%d\n", arr[++i]);
printf("%d\n", arr[j++]);
```

output

```
1
0
```
Điểm khác biệt nằm ở chỗ, nếu sử dụng i++ thì mảng sẽ đọc giá trị i = 0 trước nên sẽ trả về phần tử đầu tiên.
Còn đối với ++j thì khi này giá trị j sẽ tăng lên 1 trước, sau đó mảng mới đọc giá trị j mới này. Nên mảng sẽ trả về phần tử thứ 2.

