# Tìm hiểu về các khái niệm
- Struct
  - Khái niệm
  - Cú pháp
  - Data Alignment
  - Data Padding
  - Kích thước struct
- Bit Field
- Union
# 1. STRUCT
## 1.1 Khái niệm
- Trong ngôn ngữ lập trình C, struct là một cấu trúc dữ liệu cho phép lập trình viên tự định nghĩa một kiểu dữ liệu mới bằng cách nhóm các biến có các kiểu dữ liệu khác nhau lại với nhau. struct cho phép tạo ra một thực thể dữ liệu lớn hơn và có tổ chức hơn từ các thành viên (members) của nó.
## 1.2 Cú pháp

```cpp
  struct name_struct
{
  <data type 1> <member 1>;
  <data type 2> <member 2>;
  ...
};  
```

Kết hợp với typedef: Sẽ giúp cho code gọn hơn, không cần dùng Struct để khai báo nữa.

```cpp
  typedef struct
{
  <data type 1> <member 1>;
  <data type 2> <member 2>;
  ...
} name_struct;
```

Ví dụ về Struct:

```cpp
#include <stdio.h>
#include <stdint.h>

struct Example
{
  uint8_t a;
  uint16_t b;
  uint32_t c;
};

typedef struct
{
  uint8_t a;
  uint16_t b;
  uint32_t c;
} Ex2;

int main(){

  struct Example Ex1;
  Ex2 ex1;

  //Gán giá trị thử
  Ex1.a = 16;
  ex1.a = 20;

  printf("a = %d\n", Ex1.a);
  printf("a = %d\n", ex1.a); 
  return 0;
}
```
## 1.3 Data Alignment
- Các biến thành phần sẽ được cấp phát dữ liệu theo biến thành phần
có kích thước lớn nhất. 
- Tuy nhiên, số biến và số lần cấp phát không bằng nhau. Tức là
các biến thành phần hoàn toàn có thể sử dụng lại vùng nhớ được cấp phát 
lần trước.

<br>

Lấy ví dụ:

```cpp
  tydef struct
{
  uint16_t a; //2 Bytes
  uint8_t b; //1 Byte
  uint32_t c; //4 Bytes
};  
```
Khi này các biến thành viên sẽ được cấp phát bộ nhớ 
theo biến thành viên có kích thước lớn nhất, đó chính là
4 Bytes. Vậy các biến thành viên sẽ sử dụng kích thước bộ nhớ
được cấp phát đó như nào?

```cpp
  tydef struct
{
  uint16_t a; //2 Bytes
  uint8_t b; //1 Byte
  uint32_t c; //4 Bytes
} Name;
```

```
Lần cấp phát thứ 1: 4 Bytes 0x00 0x01 0x02 0x04
Biến a sẽ lấy 2 Bytes 0x00 0x01
Tuy nhiên vẫn còn 2 Bytes chưa sử dụng. Khi đó,
biến b sẽ sử dụng tiếp 1 bytes tiếp theo
a: 0x00 0x01
b: 0x02
Còn dư 1 byte thừa sẽ không đủ cho biến c. Nên sẽ
có lần cấp phát thứ 2: 0x04 0x05 0x06 0x07
Khi này:
a: 0x00 0x01
b: 0x02
c: 0x04 0x05 0x06 0x07
Như vậy là sử dụng 7 Bytes và dư 1 Byte.
Đó là quá trình sắp xếp các địa chỉ ô nhớ (Data Alignment)
```

## 1.4 Data Padding
- Nhìn lại ví dụ trước, Data Padding chính là vùng nhớ còn thừa
lại. Như vậy ở ví dụ trên có 1 byte padding.
- Byte Padding có thể nằm ở vị trí bất kỳ.

```cpp
typedef struct {
  uint32_t a; //4 bytes
  uint16_t b; //2 bytes
  uint8_t c; //1 byte
//Như cách sắp xếp ở trên thì sẽ có 1 byte padding nằm ở cuối
} Name;

```

## 1.5 Size of Struct
- Kích thước của struct sẽ bằng Bytes sắp xếp + Bytes Padding

```cpp
#include <stdio.h>

tydef struct
{
  uint16_t a; //2 Bytes
  uint8_t b; //1 Byte
  uint32_t c; //4 Bytes
} Ex;

int main(){
  Ex ex1;
  printf("Size of Struct: %d", sizeof(ex1));
  return 0;
}

```
output
```
Size of Struct: 8
```
# 2. Bit Field
- Trong C, “bit field” (trường bit) là một thành phần đặc biệt của cấu trúc (struct) cho
phép bạn chỉ định số lượng bit cụ thể dùng để lưu trữ một biến số nguyên. Thay vì sử
dụng toàn bộ kích thước của một kiểu dữ liệu, bạn có thể “cắt nhỏ” bộ nhớ theo số bit
cần thiết, giúp tiết kiệm không gian bộ nhớ và mô tả chính xác hơn ý nghĩa của dữ liệu
(ví dụ: lưu trạng thái bật/tắt chỉ cần 1 bit)
- Đặc điểm:
  - Không xác định được vùng nhớ mà nó truy cập
  - Không truy cập được địa chỉ của bit

```cpp
#include <stdio.h>
#include <stdint.h>

typedef struct {
  uint8_t a : 1; //Sử dụng 1 bit trong 8 bits
  uint16_t b : 3; //Sử dụng 3 bits trong 16 bits
} Example;

int main(){
  Example Ex1;

  Ex1.a = 1;
  printf("%d", &Ex1.a));

  return 0;
}

```
```
Không in được địa chỉ
```






